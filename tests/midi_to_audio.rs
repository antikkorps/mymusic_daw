// Integration test: MIDI → Audio end-to-end
//
// This test verifies that MIDI events correctly trigger audio generation
// through the entire pipeline: MIDI input → AudioEngine → audio output

use mymusic_daw::midi::event::{MidiEvent, MidiEventTimed};
use mymusic_daw::synth::voice_manager::VoiceManager;

#[test]
fn test_midi_to_audio_pipeline() {
    const SAMPLE_RATE: f32 = 48000.0;
    const BUFFER_SIZE: usize = 512;

    // Create a VoiceManager (the core audio synthesis component)
    let mut voice_manager = VoiceManager::new(SAMPLE_RATE);

    // Test 1: Silence before any notes
    let mut silent = true;
    for _ in 0..BUFFER_SIZE {
        let sample = voice_manager.next_sample();
        if sample.0.abs() > 0.0001 {
            silent = false;
            break;
        }
    }
    assert!(silent, "Audio should be silent before any note is triggered");

    // Test 2: NoteOn generates audio
    voice_manager.note_on(60, 100); // Middle C, velocity 100

    let mut has_audio = false;
    for _ in 0..BUFFER_SIZE {
        let sample = voice_manager.next_sample();
        if sample.0.abs() > 0.01 {
            has_audio = true;
            break;
        }
    }
    assert!(
        has_audio,
        "Audio should be generated after NoteOn (Middle C)"
    );

    // Test 3: NoteOff stops audio (after release phase completes)
    voice_manager.note_off(60);

    // Process samples through the release phase
    // Default release is 0.2s = 0.2 * 48000 = 9600 samples
    for _ in 0..10000 {
        voice_manager.next_sample();
    }

    // Now audio should be silent again
    silent = true;
    for _ in 0..BUFFER_SIZE {
        let sample = voice_manager.next_sample();
        if sample.0.abs() > 0.0001 {
            silent = false;
            break;
        }
    }
    assert!(silent, "Audio should be silent after NoteOff and release phase");
}

#[test]
fn test_midi_polyphony() {
    const SAMPLE_RATE: f32 = 48000.0;
    let mut voice_manager = VoiceManager::new(SAMPLE_RATE);

    // Trigger multiple notes
    voice_manager.note_on(60, 100); // C
    voice_manager.note_on(64, 100); // E
    voice_manager.note_on(67, 100); // G

    // Generate audio and verify it's not silent
    let mut has_audio = false;
    for _ in 0..512 {
        let sample = voice_manager.next_sample();
        if sample.0.abs() > 0.01 {
            has_audio = true;
            break;
        }
    }
    assert!(has_audio, "Polyphonic notes should generate audio");

    // Turn off one note, audio should still be generated by the other two
    voice_manager.note_off(64);

    has_audio = false;
    for _ in 0..512 {
        let sample = voice_manager.next_sample();
        if sample.0.abs() > 0.01 {
            has_audio = true;
            break;
        }
    }
    assert!(
        has_audio,
        "Audio should continue after turning off one note (2 remaining)"
    );

    // Turn off all notes
    voice_manager.note_off(60);
    voice_manager.note_off(67);

    // Process samples through the release phase
    // Default release is 0.2s = 0.2 * 48000 = 9600 samples
    for _ in 0..10000 {
        voice_manager.next_sample();
    }

    let mut silent = true;
    for _ in 0..512 {
        let sample = voice_manager.next_sample();
        if sample.0.abs() > 0.0001 {
            silent = false;
            break;
        }
    }
    assert!(silent, "Audio should be silent after all notes are off and release phase");
}

#[test]
fn test_midi_event_timing() {
    // Test that MidiEventTimed can be created and processed
    let midi_event = MidiEvent::NoteOn { note: 60, velocity: 100 };
    let timed_event = MidiEventTimed {
        event: midi_event,
        samples_from_now: 0, // Immediate processing
    };

    // Verify timing information is preserved
    assert_eq!(timed_event.samples_from_now, 0);
    match timed_event.event {
        MidiEvent::NoteOn { note, velocity } => {
            assert_eq!(note, 60);
            assert_eq!(velocity, 100);
        }
        _ => panic!("Expected NoteOn event"),
    }
}

#[test]
fn test_audio_output_range() {
    const SAMPLE_RATE: f32 = 48000.0;
    let mut voice_manager = VoiceManager::new(SAMPLE_RATE);

    // Trigger a loud note
    voice_manager.note_on(60, 127); // Max velocity

    // Generate samples and verify they're within reasonable bounds
    for _ in 0..10000 {
        let sample = voice_manager.next_sample();

        // Audio should be finite (not NaN or infinity)
        assert!(
            sample.0.is_finite() && sample.1.is_finite(),
            "Audio sample should be finite: {:?}",
            sample
        );

        // Audio should be within reasonable range (with some headroom)
        // The /4.0 gain in VoiceManager should keep this under control
        assert!(
            sample.0.abs() < 10.0,
            "Audio sample too loud: {:?}",
            sample
        );
        assert!(
            sample.1.abs() < 10.0,
            "Audio sample too loud: {:?}",
            sample
        );
    }
}
